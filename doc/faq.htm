<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>Icon Programming Language FAQ</TITLE>
    <LINK REL="STYLESHEET" TYPE="text/css" HREF="istyle.css">
    <LINK REL="SHORTCUT ICON" HREF="shortcut.gif">
</HEAD>
<BODY>
<!-- Archive-name: comp-lang-icon-faq-->
<P><IMG SRC="wwwcube.gif" WIDTH="128" HEIGHT="144" ALT="" ALIGN=RIGHT>
<H1>Frequently Asked Questions about the Icon programming language</H1>
<A HREF="http://www.cs.arizona.edu/icon/faq.htm">
www.cs.arizona.edu/icon/faq.htm</A>
<BR>Last updated March 24, 2004<BR>
<!-- $Id$ -->

<P><STRONG>Learning about Icon</STRONG><BR>
<A HREF="#whatsicon">A1. What is Icon?</A><BR>
<A HREF="#whatgood">A2. What is Icon good for?</A><BR>
<A HREF="#features">A3. What are Icon's distinguishing characteristics?</A><BR>
<A HREF="#library">A4. What is the Icon program library?</A><BR>
<A HREF="#intro">A5. Where can I learn more about Icon?</A><BR>
<A HREF="#documentation">A6. How about comprehensive documentation?</A><BR>
<P><STRONG>Implementations</STRONG><BR>
<A HREF="#platforms">B1. What platforms support Icon?</A><BR>
<A HREF="#getstarted">B2. How do I get started with Icon?</A><BR>
<A HREF="#unicode">B3. Is there a Unicode version of Icon?</A><BR>
<A HREF="#iconc">B4. What happened to the compiler?</A><BR>
<P><STRONG>Administration</STRONG><BR>
<A HREF="#iconproject">C1. What is the Icon Project?</A><BR>
<A HREF="#updates">C2. How often is the on-line material updated?</A><BR>
<A HREF="#lineage">C3. Where did Icon come from?</A><BR>
<A HREF="#futures">C4. Where is Icon going? </A><BR>
<P><STRONG>Support</STRONG><BR>
<A HREF="#ugroup">D1. Is there a users' group for Icon?</A><BR>
<A HREF="#techsupport">D2. How do I get technical support?</A><BR>
<P><STRONG>Programming</STRONG><BR>
<A HREF="#evread">E1. Why doesn't <CODE>read()</CODE> work with <CODE>every</CODE>?</A><BR>
<A HREF="#strinv">E2. Why doesn't string invocation such as <CODE>"foo"()</CODE> work?</A><BR>
<A HREF="#callc">E3. How can I call a C function?</A><BR>
<A HREF="#rwpipe">E4. Can I open a bidirectional pipe?</A><BR>

<P><HR><H2>Learning about Icon</H2>

<H3><A NAME="whatsicon">A1.</A> What is Icon?</H3>
<P>
Icon is a very high level general-purpose programming language with
extensive features for processing strings (text) and data structures.
Icon is an imperative, procedural language with a syntax that is
reminiscent of C and Pascal, but with semantics at a much higher level.
<P>
Icon has a novel expression-evaluation mechanism that integrates
goal-directed evaluation and backtracking with conventional control structures.
It has a string scanning facility for pattern matching that avoids the tedious
details usually associated with analyzing strings.
Icon's built-in data structures include sets and tables with associative
lookup, lists that can be used as vectors or stacks and queues, and records.
<P>
Icon is a strongly, though not statically, typed language.
It provides transparent automatic type conversion:
For example, if an integer is used in an operation that requires a string,
the integer is automatically converted to a string.
<P>
Several implementations of Icon have high-level graphics facilities with
an easily programmed window interface.
<P>
Icon manages storage automatically.
Objects are created as needed during program execution and space is
reclaimed by garbage collection as needed.
The sizes of strings and data structures are limited only by the amount
of available memory.

<H3><A NAME="whatgood">A2.</A> What is Icon good for?</H3>
<P>
As a general-purpose programming language with a large computational
repertoire, Icon can be used for most programming tasks.
It's especially strong at building software tools, for processing text,
and for experimental and research applications.
<P>
Icon is designed to make programming easy;
it emphasizes the value of programmer's
time and the importance of getting programs to work quickly.
Consequently, Icon is used both for short, one-shot tasks and for
very complex applications.

<H3><A NAME="features">A3.</A>
What are Icon's distinguishing characteristics?</H3>
<P>
<UL>
     <LI> A high-level, general-purpose programming language
     <LI> Friendly line-oriented syntax (no semicolons needed)
     <LI> Emphasis on programmer productivity
     <LI> Usually interpreted
</UL><UL>
     <LI> Evolved from programming languages (vs. scripting languages)
     <LI> Procedural control flow plus generators and goal-directed evaluation
</UL><UL>
     <LI> Values have types; variables are typeless, accept any value
     <LI> Static scoping: global or (procedure) local
     <LI> Automatic garbage collection
</UL><UL>
     <LI> All integers have arbitrary precision
     <LI> Uses strings (not chars) as basic text datatype
     <LI> Has lists that function as arrays, queues, and stacks
     <LI> Also has sets, tables, records (structs), reals (doubles), more
     <LI> No second-class "primitive types"
</UL><UL>
     <LI> Not "object-oriented" (no classes, inheritance, or instance methods)
     <LI> No exception catching
     <LI> No concurrency (no threads, monitors, semaphores, or synchronization)
     <LI> Has co-expressions (coroutines)
</UL><UL>
     <LI> Basic least-common-denominator system interface (a la ANSI C)
</UL><UL>
     <LI> Procedural graphics (event-driven paradigm available but not mandated)
     <LI> Retained windows (programs are never called to repaint)
     <LI> Simple GUI builder that can re-edit its generated code
     <LI> Turtle graphics package
</UL><UL>
   <LI> Large library of contributed procedures and programs
</UL>

<H3><A NAME="library">A4.</A> What is the Icon program library?</H3>
<P>
The library is a collection of programs and procedures written in Icon.
User contributions are welcome and form a significant portion of the library.
<P>
Library procedures effectively augment the built-in functions
available to an Icon program.
A wide variety of procedures currently exists, and most
graphically-based programs are built around library procedures.
<P>
The programs in the library range from simple demonstrations to
handy tools to complex graphical applications.
<P>
The library is a resource for both new and experienced programmers.
In addition to their basic utility,
its programs and procedures serve as examples of how things can be
written in Icon.

<H3><A NAME="intro">A5.</A> Where can I learn more about Icon?</H3>
<P>
Here are some good places to start.
<UL>
<LI> Ralph Griswold's overview:
	<A HREF="http://www.cs.arizona.edu/icon/docs/ipd266.htm">
	www.cs.arizona.edu/icon/docs/ipd266.htm</A>
<LI> Dave Hanson's introduction:
	<A HREF="http://www.cs.arizona.edu/icon/intro.htm">
	www.cs.arizona.edu/icon/intro.htm</A>
<LI> Bill Mitchell's introduction and slides:
	<A HREF="http://www.mse.com/icon/">
	www.mse.com/icon</A>
<LI> John Shipman's tutorial:
	<A HREF="http://www.nmt.edu/tcc/help/lang/icon/">
	www.nmt.edu/tcc/help/lang/icon</A>
</UL>

<H3><A NAME="documentation">A6.</A> How about comprehensive documentation?</H3>
<P>
Two books define the Icon language.
The core language is covered in
<A HREF="http://www.cs.arizona.edu/icon/lb3.htm">
<CITE>The Icon Programming Language (third edition)</CITE></A>,
by Griswold and Griswold.
Graphics facilities are described in
<A HREF="http://www.cs.arizona.edu/icon/gb/">
<CITE>Graphics Programming in Icon</CITE></A>
by Griswold, Jeffery, and Townsend.
These books contain both tutorial and reference material.
<P>
Icon's internals are detailed in
<A HREF="http://www.cs.arizona.edu/icon/ibsale.htm">
<CITE>The Implementation of the Icon Programming Language</CITE></A>
by Griswold and Griswold.
Although considerable changes have occurred since Version 6,
described in the book, the basic structure of Icon remains the same.
Two technical reports,
<A HREF="http://www.cs.arizona.edu/icon/docs/ipd112.htm">IPD112</A> and
<A HREF="http://www.cs.arizona.edu/icon/docs/ipd239.htm">IPD239</A>,
describe subsequent changes.
<P>
Printed copies of the
<CITE>Language</CITE> and <CITE>Graphics</CITE> books
are available from Jeffery Systems
(<A HREF="http://www.zianet.com/jeffery/books/">www.zianet.com/jeffery/books</A>).
The <CITE>Language</CITE> and <CITE>Implementation</CITE> books
can be downloaded at no charge from the Icon books page, 
<A HREF="http://www.cs.arizona.edu/icon/books.htm">
www.cs.arizona.edu/icon/books.htm</A>.
<P>
The <CITE>Icon Programming Language Handbook</CITE>,
by Thomas W. Christopher, is available on the web at
<A HREF="http://www.tools-of-computing.com/tc/CS/iconprog.pdf">
www.tools-of-computing.com/tc/CS/iconprog.pdf</A>.
<P>
There is a large amount of additional information at the
Icon web site,
<A HREF="http://www.cs.arizona.edu/icon/">www.cs.arizona.edu/icon</A>.

<P><HR><H2>Implementations</H2>

<H3><A NAME="platforms">B1.</A> What platforms support Icon?</H3>
<P>
Current implementations with graphics support
are available for Unix (including Linux) and Windows.
The Unix implementation also runs on Darwin,
the Macintosh development environment, or the
<A HREF="http://www.cygwin.com/">Cygwin</A> environment under Windows.
Older versions of Icon are available for some other systems.
An alternative Java-based implementation for Unix,
<A HREF="http://www.cs.arizona.edu/icon/jcon/">Jcon</A>,
is also available.

<H3><A NAME="getstarted">B2.</A> How do I get started with Icon?</H3>
<P>
Version 9.4.2 of Icon for <STRONG>Unix</STRONG> can be downloaded from
<A HREF="http://www.cs.arizona.edu/icon/v942/">
www.cs.arizona.edu/icon/v942</A>.
Source and binary packages are available, each with the
complete Icon program library.
<P>
Version 9.3 of Icon for <STRONG>Windows</STRONG> is compatible
at the source level with version 9.4.2.
It can be downloaded from
<A HREF="http://www.cs.arizona.edu/icon/v93w.htm">
www.cs.arizona.edu/icon/v93w.htm</A>.
The Version 9.4.2 library can be obtained separately from
<A HREF="http://www.cs.arizona.edu/icon/v942/">
www.cs.arizona.edu/icon/v942</A>.
<P>
For older implementations, start at
<A HREF="http://www.cs.arizona.edu/icon/implver.htm">
www.cs.arizona.edu/icon/implver.htm</A>.
Jcon is at <A HREF="http://www.cs.arizona.edu/icon/jcon/">
www.cs.arizona.edu/icon/jcon</A>.

<H3><A NAME="unicode">B3.</A> Is there a Unicode version of Icon?</H3>
<P>
No.
Icon is defined in terms of 8-bit characters, and changing this presents
several design challenges that would likely break existing programs.
Also, modifying the C implementation is probably infeasible,
but a Unicode version of Jcon might be possible.

<H3><A NAME="iconc">B4.</A> What happened to the compiler?</H3>
<P>
For a while, Unix distributions included both an interpreter and a compiler;
but the interpreter is is usually fast enough even for production work, and
most people found that using the compiler wasn't worth the extra compilation
time or the hassles involved.
We no longer advertise the compiler or produce binaries for it.
It is still part of the source code distribution,
and we have not deliberately broken it, 
but we no longer support it and we cannot offer help if problems arise.

<P><HR><H2>Administration</H2>

<H3><A NAME="iconproject">C1.</A> What is the Icon Project?</H3>
<P>
The Icon Project is a name used by the group that
distributes and supports the Icon programming language.
The project maintains the Icon web site at
<A HREF="http://www.cs.arizona.edu/icon/">www.cs.arizona.edu/icon</A>.
A non-commercial organization, the project is supported by the
Department of Computer Science at the University of Arizona.

<H3><A NAME="updates">C2.</A> How often is the on-line material updated?</H3>
<P>
New material is added when it's available.
Established implementations usually are updated only when there's a
new version.
This typically is every year or two.
The Icon program library is updated on a similar schedule.

<H3><A NAME="lineage">C3.</A> Where did Icon come from?</H3>
<P>
Icon is the latest in a series of high-level programming languages designed
to facilitate programming tasks involving strings and structures.
The original language, SNOBOL, was developed at Bell Telephone Laboratories
in the early 1960s.
SNOBOL evolved into SNOBOL4, which is still in use.
Subsequent languages were developed at the University of
Arizona with support from the National Science Foundation.
Although it has similar objectives and many similar capabilities,
Icon bears little superficial resemblance to SNOBOL4.
<P>
Icon implementations were developed by faculty, staff, and students
at the University of Arizona,
with significant contributions from volunteers around the world.
An <A HREF="http://doi.acm.org/10.1145/155360.155363">Icon history</A>
by Ralph and Madge Griswold appears in the preprints
of the second History of Programming Languages Conference (HOPL-II),
ACM SIGPLAN Notices, March 1993 (Vol 28, No 3).
<P>
The name Icon is not an acronym, nor does it stand for anything in
particular, although the word <CITE>iconoclastic</CITE> was mentioned
when the name was chosen.
The name predates the now common use of <CITE>icon</CITE>
to refer to small images used in graphical user interfaces.
This sometimes misleads people into thinking that
that Icon is designed to create or manipulate icons,
but there's no good solution to that problem.

<H3><A NAME="futures">C4.</A> Where is Icon going? </H3>
<P>
We continue to use Icon on a daily basis, but no significant changes
are planned.
We expect to support the Unix version for the forseeable future,
and to distribute ports to other systems as supplied by volunteers.
<P>
The Unicon project is developing an object-oriented language based on Icon.
For more information, see
<A HREF="http://unicon.sourceforge.net/">
unicon.sourceforge.net</A>.


An earlier object-oriented extension to Icon, Idol,
can be found in the Icon program library.

<P><HR><H2>Support</H2>

<H3><A NAME="ugroup">D1.</A> Is there a users' group for Icon?</H3>
<P>
There is no official Icon users' group, but the Usenet newsgroup
<A HREF="news:comp.lang.icon">comp.lang.icon</A>
is dedicated to issues relating to the Icon language.

<H3><A NAME="techsupport">D2.</A> How do I get technical support?</H3>
<P>
The Icon Project is not a commercial organization, and its capacity for
providing technical support is limited. Please use the appropriate resource
when you need assistance:
<UL>
<LI>
For <STRONG>programming</STRONG> questions,
submit a query to the Usenet newsgroup
<A HREF="news:comp.lang.icon">comp.lang.icon</A>.
<LI>
For <STRONG>porting</STRONG> assistance
or <STRONG>Unix</STRONG> problems, contact
<A HREF="mailto:icon-project@cs.arizona.edu">icon-project@cs.arizona.edu</A>.
<LI>
For problems with the <STRONG>Windows</STRONG> implementation,
contact the implementor,
<A HREF="mailto:jeffery@cs.nmsu.edu">jeffery@cs.nmsu.edu</A>.
<LI>
For general information and additional documentation, visit the Icon web site:
<A HREF="http://www.cs.arizona.edu/icon/">www.cs.arizona.edu/icon</A>.
</UL>

<P><HR><H2>Programming</H2>

<H3><A NAME="evread">E1.</A>
Why doesn't <CODE>read()</CODE> work with <CODE>every</CODE>?</H3>
<P>
<CODE>every s := read() do {...}</CODE>
doesn't loop because <CODE>read()</CODE> produces a single value and
then fails if resumed.
Other "consumer" procedures such as <CODE>get()</CODE> and <CODE>pop()</CODE>
work the same way.
Use a <CODE>while</CODE> loop with these procedures, and save
<CODE>every</CODE> for use with generators such as <CODE>!x</CODE>
or <CODE>key(T)</CODE>.

<H3><A NAME="strinv">E2.</A>
Why doesn't string invocation such as <CODE>"foo"()</CODE> work?</H3>
<P>
String invocation works if the procedure is present;
the catch is that the linker removes unreferenced procedures.
To ensure a procedure's presence, reference it in the
<CODE>main()</CODE> procedure.
A simple reference suffices, as in
<CODE>refs := [foo, bar, baz]</CODE>;
it's not necessary to actually call it.
<P>
(Why does the linker remove unreferenced procedures?
Because this can save <EM>huge</EM> amounts of memory for
programs that use the library.)

<H3><A NAME="callc">E3.</A> How can I call a C function?</H3>
<P>
You can't call an arbitrary C function, 
but if you're willing to write a function to Icon's specifications,
there are two approaches.
Under Unix, which provides <CODE>loadfunc()</CODE>,
you can load one or more functions from a shared library,
and then treat them as if they had been written in Icon.
Some examples can be found in the
<A HREF="http://www.cs.arizona.edu/icon/library/ccfuncs.htm">
<CODE>cfuncs</CODE></A> and
<CODE>packs/loadfuncs</CODE> directories of the Icon program library.
The more cumbersome approach is to add code to the Icon interpreter
and rebuild it; some hooks are provided for this purpose.
Both approaches are discussed in <CITE>Calling C Functions from Icon</CITE>,
<A HREF="http://www.cs.arizona.edu/icon/docs/ipd240.htm">
www.cs.arizona.edu/icon/docs/ipd240.htm</A>.
<P>
The <A HREF="http://www.cs.arizona.edu/icon/jcon/">Jcon</A> implementation
allows Icon programs to call Java code that is written to Jcon specifications.

<H3><A NAME="rwpipe">E4.</A> Can I open a bidirectional pipe?</H3>
<P>
No, this is not possible.
Although the concept is simple &mdash; 
write a line to a program via a pipe, then read that program's output
&mdash; it probably wouldn't work.
Most I/O libraries don't write anything to a pipe until
they've filled a buffer, and the most likely consequence would be
a deadlock, with each program waiting for the other to send more data.

<P><HR>
<SMALL>
This FAQ is edited by Gregg Townsend.
It includes contributions from
Ralph Griswold, Cliff Hathaway, Clint Jeffery, Bob Alexander,
and Todd Proebsting.
</SMALL>
</BODY>
</HTML>
