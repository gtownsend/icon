# define IDENT 257
# define INTLIT 258
# define REALLIT 259
# define STRINGLIT 260
# define CSETLIT 261
# define EOFX 262
# define BREAK 263
# define BY 264
# define CASE 265
# define CREATE 266
# define DEFAULT 267
# define DO 268
# define ELSE 269
# define END 270
# define EVERY 271
# define FAIL 272
# define GLOBAL 273
# define IF 274
# define INITIAL 275
# define INVOCABLE 276
# define LINK 277
# define LOCAL 278
# define NEXT 279
# define NOT 280
# define OF 281
# define PROCEDURE 282
# define RECORD 283
# define REPEAT 284
# define RETURN 285
# define STATIC 286
# define SUSPEND 287
# define THEN 288
# define TO 289
# define UNTIL 290
# define WHILE 291
# define BANG 292
# define MOD 293
# define AUGMOD 294
# define AND 295
# define AUGAND 296
# define STAR 297
# define AUGSTAR 298
# define INTER 299
# define AUGINTER 300
# define PLUS 301
# define AUGPLUS 302
# define UNION 303
# define AUGUNION 304
# define MINUS 305
# define AUGMINUS 306
# define DIFF 307
# define AUGDIFF 308
# define DOT 309
# define SLASH 310
# define AUGSLASH 311
# define ASSIGN 312
# define SWAP 313
# define NMLT 314
# define AUGNMLT 315
# define REVASSIGN 316
# define REVSWAP 317
# define SLT 318
# define AUGSLT 319
# define SLE 320
# define AUGSLE 321
# define NMLE 322
# define AUGNMLE 323
# define NMEQ 324
# define AUGNMEQ 325
# define SEQ 326
# define AUGSEQ 327
# define EQUIV 328
# define AUGEQUIV 329
# define NMGT 330
# define AUGNMGT 331
# define NMGE 332
# define AUGNMGE 333
# define SGT 334
# define AUGSGT 335
# define SGE 336
# define AUGSGE 337
# define QMARK 338
# define AUGQMARK 339
# define AT 340
# define AUGAT 341
# define BACKSLASH 342
# define CARET 343
# define AUGCARET 344
# define BAR 345
# define CONCAT 346
# define AUGCONCAT 347
# define LCONCAT 348
# define AUGLCONCAT 349
# define TILDE 350
# define NMNE 351
# define AUGNMNE 352
# define SNE 353
# define AUGSNE 354
# define NEQUIV 355
# define AUGNEQUIV 356
# define LPAREN 357
# define RPAREN 358
# define PCOLON 359
# define COMMA 360
# define MCOLON 361
# define COLON 362
# define SEMICOL 363
# define LBRACK 364
# define RBRACK 365
# define LBRACE 366
# define RBRACE 367

# line 145 "tgram.g"
/*
 * These commented directives are passed through the first application
 * of cpp, then turned into real includes in tgram.g by fixgram.icn.
 */
#include "../h/gsupport.h"
#undef T_Real
#undef T_String
#undef T_Cset
#include "../h/lexdef.h"
#include "tproto.h"
#include "tglobals.h"
#include "tsym.h"
#include "tree.h"
#include "keyword.h"
#undef YYSTYPE
#define YYSTYPE nodeptr
#define YYMAXDEPTH 500

extern int fncargs[];
int idflag;
int id_cnt;



#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

# line 442 "tgram.g"


/*
 * xfree(p) -- used with free(p) macro to avoid compiler errors from
 *  miscast free calls generated by Yacc.
 */
static void xfree(p)
char *p;
{
   free(p);
}

#define free(p) xfree((char*)p)
int yyexca[] ={
-1, 0,
	262, 2,
	273, 2,
	276, 2,
	277, 2,
	282, 2,
	283, 2,
	-2, 0,
-1, 1,
	0, -1,
	-2, 0,
-1, 20,
	270, 40,
	363, 42,
	-2, 0,
-1, 86,
	264, 42,
	268, 42,
	269, 42,
	281, 42,
	288, 42,
	289, 42,
	293, 42,
	294, 42,
	296, 42,
	298, 42,
	300, 42,
	302, 42,
	304, 42,
	306, 42,
	308, 42,
	311, 42,
	312, 42,
	313, 42,
	314, 42,
	315, 42,
	316, 42,
	317, 42,
	318, 42,
	319, 42,
	320, 42,
	321, 42,
	322, 42,
	323, 42,
	325, 42,
	327, 42,
	329, 42,
	330, 42,
	331, 42,
	332, 42,
	333, 42,
	334, 42,
	335, 42,
	336, 42,
	337, 42,
	339, 42,
	341, 42,
	344, 42,
	347, 42,
	349, 42,
	352, 42,
	354, 42,
	356, 42,
	358, 42,
	359, 42,
	360, 42,
	361, 42,
	362, 42,
	363, 42,
	365, 42,
	367, 42,
	-2, 0,
-1, 87,
	358, 42,
	360, 42,
	-2, 0,
-1, 88,
	363, 42,
	367, 42,
	-2, 0,
-1, 89,
	360, 42,
	365, 42,
	-2, 0,
-1, 96,
	264, 42,
	268, 42,
	269, 42,
	281, 42,
	288, 42,
	289, 42,
	293, 42,
	294, 42,
	296, 42,
	298, 42,
	300, 42,
	302, 42,
	304, 42,
	306, 42,
	308, 42,
	311, 42,
	312, 42,
	313, 42,
	314, 42,
	315, 42,
	316, 42,
	317, 42,
	318, 42,
	319, 42,
	320, 42,
	321, 42,
	322, 42,
	323, 42,
	325, 42,
	327, 42,
	329, 42,
	330, 42,
	331, 42,
	332, 42,
	333, 42,
	334, 42,
	335, 42,
	336, 42,
	337, 42,
	339, 42,
	341, 42,
	344, 42,
	347, 42,
	349, 42,
	352, 42,
	354, 42,
	356, 42,
	358, 42,
	359, 42,
	360, 42,
	361, 42,
	362, 42,
	363, 42,
	365, 42,
	367, 42,
	-2, 0,
-1, 97,
	264, 42,
	268, 42,
	269, 42,
	281, 42,
	288, 42,
	289, 42,
	293, 42,
	294, 42,
	296, 42,
	298, 42,
	300, 42,
	302, 42,
	304, 42,
	306, 42,
	308, 42,
	311, 42,
	312, 42,
	313, 42,
	314, 42,
	315, 42,
	316, 42,
	317, 42,
	318, 42,
	319, 42,
	320, 42,
	321, 42,
	322, 42,
	323, 42,
	325, 42,
	327, 42,
	329, 42,
	330, 42,
	331, 42,
	332, 42,
	333, 42,
	334, 42,
	335, 42,
	336, 42,
	337, 42,
	339, 42,
	341, 42,
	344, 42,
	347, 42,
	349, 42,
	352, 42,
	354, 42,
	356, 42,
	358, 42,
	359, 42,
	360, 42,
	361, 42,
	362, 42,
	363, 42,
	365, 42,
	367, 42,
	-2, 0,
-1, 111,
	270, 40,
	363, 42,
	-2, 0,
-1, 117,
	270, 40,
	363, 42,
	-2, 0,
-1, 182,
	360, 42,
	365, 42,
	-2, 0,
-1, 183,
	360, 42,
	-2, 0,
-1, 184,
	358, 42,
	360, 42,
	-2, 0,
-1, 311,
	358, 42,
	360, 42,
	365, 42,
	-2, 0,
-1, 313,
	363, 42,
	367, 42,
	-2, 0,
-1, 335,
	360, 42,
	367, 42,
	-2, 0,
	};
# define YYNPROD 203
# define YYLAST 728
int yyact[]={

    38,    84,    91,    92,    93,    94,   312,    86,   185,    99,
    83,   118,   335,   359,   341,   102,    95,   358,    98,   334,
   311,   311,   355,    85,    51,   329,   314,    20,   103,    96,
   118,    97,   313,   228,   101,   100,    56,   346,   118,    90,
   118,    59,   117,    62,   360,    58,   108,    70,   336,    64,
   311,    57,   228,    55,    60,   326,   184,   228,   310,   119,
   311,   107,   106,   182,   345,   183,   324,   232,    65,   110,
    67,   168,    69,   169,   352,   214,   118,   350,   328,   177,
    41,   356,    71,   174,    50,   175,    73,    61,   325,    52,
    53,   320,    54,   316,    63,    66,   176,    68,   327,    72,
   118,    87,   332,   118,   333,   331,   319,   361,    89,   116,
    88,   305,    38,    84,    91,    92,    93,    94,   118,    86,
   181,    99,    83,   353,   317,   231,     3,   102,    95,   218,
    98,   318,   105,   118,    19,    85,    51,   315,   118,    28,
   103,    96,    29,    97,   217,   321,   101,   100,    56,   309,
   170,    90,   172,    59,   173,    62,   171,    58,   118,    70,
    30,    64,    18,    57,   118,    55,    60,    44,   180,    37,
   179,   178,   113,    24,   104,   114,    25,   330,   351,   306,
    65,   212,    67,   115,    69,    82,     2,    81,    80,    27,
    17,    36,    23,    79,    71,    78,    50,    77,    73,    61,
    76,    52,    53,    75,    54,    74,    63,    66,    49,    68,
    47,    72,    42,    87,    38,    84,    91,    92,    93,    94,
    89,    86,    88,    99,    83,    40,   112,   322,   109,   102,
    95,    34,    98,   273,   274,   111,    33,    85,    51,    12,
   233,    32,   103,    96,    21,    97,    22,    26,   101,   100,
    56,    10,     9,    90,     8,    59,     7,    62,    31,    58,
     6,    70,     5,    64,     1,    57,     0,    55,    60,    13,
     0,   216,    15,    14,     0,   210,     0,     0,    16,    11,
     0,     0,    65,     0,    67,   234,    69,   236,   239,   221,
   222,   223,   224,   225,   226,   227,    71,   230,    50,   229,
    73,    61,     0,    52,    53,   237,    54,     0,    63,    66,
     0,    68,     0,    72,     0,    87,    46,    84,    91,    92,
    93,    94,    89,    86,    88,    99,    83,    45,     0,     0,
     0,   102,    95,     0,    98,     0,   289,   290,     0,    85,
    51,     0,     0,   235,   103,    96,     0,    97,     0,   238,
   101,   100,    56,     0,     0,    90,     0,    59,     0,    62,
     0,    58,     4,    70,   303,    64,   308,    57,     0,    55,
    60,     0,     0,    13,   304,     0,    15,    14,     0,     0,
     0,     0,    16,    11,    65,     0,    67,     0,    69,   338,
     0,   213,     0,     0,     0,     0,     0,     0,    71,    43,
    50,     0,    73,    61,     0,    52,    53,   323,    54,   347,
    63,    66,    35,    68,   152,    72,     0,    87,     0,   133,
     0,   150,     0,   130,    89,   131,    88,   128,     0,   127,
     0,   129,     0,   126,   362,     0,   132,   121,   120,     0,
   140,   123,   122,     0,   147,   164,   146,     0,   139,   158,
   135,   157,   143,   163,   136,   160,   138,   154,   137,   166,
   145,   162,   144,   161,   149,   156,   151,   155,     0,   134,
     0,     0,   124,     0,   125,     0,   153,   141,   211,   148,
   215,   142,   165,    39,   159,     0,   167,     0,   219,   220,
     0,   295,   296,   297,   298,   299,     0,     0,   291,   292,
   293,   294,     0,    35,     0,     0,     0,   339,   340,    35,
   342,   343,   344,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   348,     0,     0,     0,    48,     0,     0,     0,
     0,     0,     0,   354,     0,     0,     0,     0,     0,     0,
     0,     0,   357,     0,     0,     0,     0,     0,     0,     0,
     0,   354,   363,   364,   275,   276,   277,   278,   279,   280,
   281,   282,   283,   284,   285,   286,   287,   288,     0,     0,
     0,     0,     0,     0,     0,   307,     0,   186,   187,   188,
   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,
   199,   200,   201,   202,   203,   204,   205,   206,   207,   208,
   209,     0,     0,   240,   241,   242,   243,   244,   245,   246,
   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,
   257,   258,   259,   260,   261,   262,   263,   264,   265,   266,
   267,   268,   269,   270,   271,   272,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   337,     0,   215,   300,   301,   302,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   349 };
int yypact[]={

  -130, -1000,   100, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000,   -95,  -229, -1000,   -84,  -118,   -97,    -4, -1000, -1000,
   -42,  -125,  -298, -1000, -1000, -1000,  -299, -1000, -1000,  -316,
 -1000, -1000,  -288,  -103,  -161,  -321,  -219,  -279, -1000, -1000,
   125, -1000,   131,  -275,  -151,  -214, -1000,  -172, -1000,  -301,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000,   -42, -1000, -1000,   -42,   -42,   -42,   -42,
  -128, -1000, -1000, -1000, -1000, -1000,   -42,   -42,   -42,   -42,
   -42,   -42,   -42,   -42,  -303, -1000,   -84,  -118,  -133,  -290,
  -125,   -42,  -125,   -42, -1000, -1000, -1000,   -42,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
    60,    60,   -42,  -256,   -42,  -108, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
  -219, -1000,  -300, -1000,  -361,  -331,  -339, -1000, -1000, -1000,
 -1000,  -131,  -195,  -157,  -137,  -162,  -177,  -219,  -112, -1000,
 -1000, -1000,  -125,  -292,  -303,  -182,  -308,  -265, -1000,  -279,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000,  -186, -1000,  -275,  -275,  -275,  -275,  -275,
  -275,  -275,  -275,  -275,  -275,  -275,  -275,  -275,  -275,  -151,
  -151,  -214,  -214,  -214,  -214, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000,  -340,  -257, -1000,  -348, -1000,  -310, -1000,
 -1000,   -42, -1000,   -42, -1000,   -42,   -42,  -352,   -42,   -42,
   -42, -1000,  -294,  -327, -1000, -1000, -1000, -1000,    60, -1000,
   -42, -1000, -1000, -1000, -1000,   -42, -1000, -1000, -1000,  -219,
  -192,  -144,  -219,  -219,  -219, -1000,  -343, -1000,  -284, -1000,
   -42,  -350, -1000,  -318,  -255, -1000, -1000,  -219, -1000,  -144,
   -42,   -42, -1000,  -219,  -219 };
int yypgo[]={

     0,   264,   186,   262,   260,   256,   254,   252,   251,   247,
   189,   246,   192,   244,   174,   241,   240,   239,   236,   235,
   231,   228,   227,   226,   191,   391,   169,   483,   225,    80,
   212,   399,   167,   327,   316,   210,   526,   208,   205,   203,
   200,   197,   195,   193,   188,   187,   185,   181,    75,   179,
   178,    74,   177 };
int yyr1[]={

     0,     1,     2,     2,     3,     3,     3,     3,     3,     8,
     9,     9,    10,    10,    10,     7,    11,    11,    12,    12,
    13,     6,    15,     4,    16,    16,     5,    21,    17,    22,
    22,    22,    14,    14,    18,    18,    23,    23,    19,    19,
    20,    20,    25,    25,    24,    24,    26,    26,    27,    27,
    27,    27,    27,    27,    27,    27,    27,    27,    27,    27,
    27,    27,    27,    27,    27,    27,    27,    27,    27,    27,
    27,    27,    27,    27,    27,    27,    27,    27,    27,    27,
    27,    28,    28,    28,    29,    29,    30,    30,    30,    30,
    30,    30,    30,    30,    30,    30,    30,    30,    30,    30,
    30,    31,    31,    31,    32,    32,    32,    32,    32,    33,
    33,    33,    33,    33,    34,    34,    35,    35,    35,    35,
    36,    36,    36,    36,    36,    36,    36,    36,    36,    36,
    36,    36,    36,    36,    36,    36,    36,    36,    36,    36,
    36,    36,    36,    36,    36,    37,    37,    37,    37,    37,
    37,    37,    37,    37,    37,    37,    37,    37,    37,    37,
    37,    37,    37,    37,    37,    37,    37,    37,    43,    43,
    44,    44,    45,    45,    46,    40,    40,    40,    40,    41,
    41,    42,    50,    50,    51,    51,    47,    47,    49,    49,
    38,    38,    38,    38,    39,    52,    52,    52,    48,    48,
     1,     5,    24 };
int yyr2[]={

     0,     5,     0,     4,     3,     3,     3,     3,     3,     5,
     2,     7,     3,     3,     7,     5,     2,     7,     3,     3,
     1,     7,     1,    13,     1,     3,    13,     1,    13,     1,
     3,     7,     3,     7,     1,     9,     3,     3,     1,     7,
     1,     7,     1,     2,     2,     7,     2,     7,     2,     7,
     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
     7,     2,     7,    11,     2,     7,     2,     7,     7,     7,
     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
     7,     2,     7,     7,     2,     7,     7,     7,     7,     2,
     7,     7,     7,     7,     2,     7,     2,     7,     7,     7,
     2,     5,     5,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     5,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     5,     3,     3,     5,     7,     7,
     7,     9,     7,     9,     9,     7,     5,     5,     5,     9,
     5,     9,     5,     9,     5,     3,     5,     5,     9,     9,
    13,    13,     2,     7,     7,     7,     3,     7,     3,     7,
     3,     3,     3,     3,    13,     3,     3,     3,     2,     7,
     6,     8,     2 };
int yychk[]={

 -1000,    -1,    -2,   256,   262,    -3,    -4,    -5,    -6,    -7,
    -8,   283,   -17,   273,   277,   276,   282,    -2,   257,   363,
   256,   -13,   -11,   -12,   257,   260,    -9,   -10,   257,   260,
   257,   262,   -15,   -18,   -20,   -25,   -24,   -26,   256,   -27,
   -28,   -29,   -30,   -31,   -32,   -33,   -34,   -35,   -36,   -37,
   340,   280,   345,   346,   348,   309,   292,   307,   301,   297,
   310,   343,   299,   350,   305,   324,   351,   326,   353,   328,
   303,   338,   355,   342,   -38,   -39,   -40,   -41,   -42,   -43,
   -44,   -45,   -46,   266,   257,   279,   263,   357,   366,   364,
   295,   258,   259,   260,   261,   272,   285,   287,   274,   265,
   291,   290,   271,   284,   -14,   257,   360,   360,   362,   -21,
   357,   -19,   -23,   275,   278,   286,   270,   363,   295,   338,
   313,   312,   317,   316,   347,   349,   308,   304,   302,   306,
   298,   300,   311,   294,   344,   325,   329,   333,   331,   323,
   315,   352,   356,   327,   337,   335,   321,   319,   354,   339,
   296,   341,   289,   345,   326,   336,   334,   320,   318,   353,
   324,   332,   330,   322,   314,   351,   328,   355,   346,   348,
   301,   307,   303,   305,   297,   299,   310,   293,   343,   342,
   340,   292,   364,   366,   357,   309,   -36,   -36,   -36,   -36,
   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,
   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,   -36,
   -24,   -25,   -47,   -25,   -48,   -25,   -47,   272,   257,   -25,
   -25,   -24,   -24,   -24,   -24,   -24,   -24,   -24,   360,   -12,
   -10,   258,   357,   -16,   -14,   -20,   -14,   -24,   -20,   -26,
   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,   -27,
   -27,   -27,   -27,   -29,   -29,   -31,   -31,   -31,   -31,   -31,
   -31,   -31,   -31,   -31,   -31,   -31,   -31,   -31,   -31,   -32,
   -32,   -33,   -33,   -33,   -33,   -34,   -34,   -34,   -34,   -34,
   -36,   -36,   -36,   -47,   -24,   367,   -49,   -25,   -47,   257,
   358,   360,   367,   363,   365,   268,   288,   281,   268,   268,
   268,   257,   -22,   -14,   358,   270,   363,   363,   264,   365,
   -52,   362,   359,   361,   367,   360,   358,   -25,   -48,   -24,
   -24,   366,   -24,   -24,   -24,   358,   364,   -29,   -24,   -25,
   269,   -50,   -51,   267,   -24,   365,   365,   -24,   367,   363,
   362,   362,   -51,   -24,   -24 };
int yydef[]={

    -2,    -2,     0,     2,     1,     3,     4,     5,     6,     7,
     8,     0,     0,    20,     0,     0,     0,     0,    22,    34,
    -2,     0,    15,    16,    18,    19,     9,    10,    12,    13,
    27,   200,     0,    38,     0,     0,    43,    44,   202,    46,
    48,    81,    84,    86,   101,   104,   109,   114,   116,   120,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   145,   146,   147,   148,   149,   150,
   151,   152,   153,     0,   155,   156,    -2,    -2,    -2,    -2,
     0,   190,   191,   192,   193,   175,    -2,    -2,     0,     0,
     0,     0,     0,     0,    21,    32,     0,     0,     0,     0,
    24,    -2,     0,     0,    36,    37,   201,    -2,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    -2,    -2,    -2,     0,   121,   122,   123,   124,
   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,
   154,   157,     0,   186,     0,   198,     0,   166,   167,   176,
   177,    43,     0,     0,   168,   170,   172,   174,     0,    17,
    11,    14,    29,     0,    25,     0,     0,     0,    41,    45,
    47,    49,    50,    51,    52,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,
    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,
    78,    79,    80,    82,    85,    87,    88,    89,    90,    91,
    92,    93,    94,    95,    96,    97,    98,    99,   100,   102,
   103,   105,   106,   107,   108,   110,   111,   112,   113,   115,
   117,   118,   119,     0,    43,   162,     0,   188,     0,   165,
   158,    -2,   159,    -2,   160,     0,     0,     0,     0,     0,
     0,    33,     0,    30,    23,    26,    35,    39,     0,   161,
     0,   195,   196,   197,   163,    -2,   164,   187,   199,   178,
   179,     0,   169,   171,   173,    28,     0,    83,     0,   189,
     0,     0,   182,     0,     0,    31,   194,   180,   181,     0,
     0,     0,   183,   184,   185 };
typedef struct { char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"IDENT",	257,
	"INTLIT",	258,
	"REALLIT",	259,
	"STRINGLIT",	260,
	"CSETLIT",	261,
	"EOFX",	262,
	"BREAK",	263,
	"BY",	264,
	"CASE",	265,
	"CREATE",	266,
	"DEFAULT",	267,
	"DO",	268,
	"ELSE",	269,
	"END",	270,
	"EVERY",	271,
	"FAIL",	272,
	"GLOBAL",	273,
	"IF",	274,
	"INITIAL",	275,
	"INVOCABLE",	276,
	"LINK",	277,
	"LOCAL",	278,
	"NEXT",	279,
	"NOT",	280,
	"OF",	281,
	"PROCEDURE",	282,
	"RECORD",	283,
	"REPEAT",	284,
	"RETURN",	285,
	"STATIC",	286,
	"SUSPEND",	287,
	"THEN",	288,
	"TO",	289,
	"UNTIL",	290,
	"WHILE",	291,
	"BANG",	292,
	"MOD",	293,
	"AUGMOD",	294,
	"AND",	295,
	"AUGAND",	296,
	"STAR",	297,
	"AUGSTAR",	298,
	"INTER",	299,
	"AUGINTER",	300,
	"PLUS",	301,
	"AUGPLUS",	302,
	"UNION",	303,
	"AUGUNION",	304,
	"MINUS",	305,
	"AUGMINUS",	306,
	"DIFF",	307,
	"AUGDIFF",	308,
	"DOT",	309,
	"SLASH",	310,
	"AUGSLASH",	311,
	"ASSIGN",	312,
	"SWAP",	313,
	"NMLT",	314,
	"AUGNMLT",	315,
	"REVASSIGN",	316,
	"REVSWAP",	317,
	"SLT",	318,
	"AUGSLT",	319,
	"SLE",	320,
	"AUGSLE",	321,
	"NMLE",	322,
	"AUGNMLE",	323,
	"NMEQ",	324,
	"AUGNMEQ",	325,
	"SEQ",	326,
	"AUGSEQ",	327,
	"EQUIV",	328,
	"AUGEQUIV",	329,
	"NMGT",	330,
	"AUGNMGT",	331,
	"NMGE",	332,
	"AUGNMGE",	333,
	"SGT",	334,
	"AUGSGT",	335,
	"SGE",	336,
	"AUGSGE",	337,
	"QMARK",	338,
	"AUGQMARK",	339,
	"AT",	340,
	"AUGAT",	341,
	"BACKSLASH",	342,
	"CARET",	343,
	"AUGCARET",	344,
	"BAR",	345,
	"CONCAT",	346,
	"AUGCONCAT",	347,
	"LCONCAT",	348,
	"AUGLCONCAT",	349,
	"TILDE",	350,
	"NMNE",	351,
	"AUGNMNE",	352,
	"SNE",	353,
	"AUGSNE",	354,
	"NEQUIV",	355,
	"AUGNEQUIV",	356,
	"LPAREN",	357,
	"RPAREN",	358,
	"PCOLON",	359,
	"COMMA",	360,
	"MCOLON",	361,
	"COLON",	362,
	"SEMICOL",	363,
	"LBRACK",	364,
	"RBRACK",	365,
	"LBRACE",	366,
	"RBRACE",	367,
	"-unknown-",	-1	/* ends search */
};

char * yyreds[] =
{
	"-no such reduction-",
	"program : decls EOFX",
	"decls : /* empty */",
	"decls : decls decl",
	"decl : record",
	"decl : proc",
	"decl : global",
	"decl : link",
	"decl : invocable",
	"invocable : INVOCABLE invoclist",
	"invoclist : invocop",
	"invoclist : invoclist COMMA invocop",
	"invocop : IDENT",
	"invocop : STRINGLIT",
	"invocop : STRINGLIT COLON INTLIT",
	"link : LINK lnklist",
	"lnklist : lnkfile",
	"lnklist : lnklist COMMA lnkfile",
	"lnkfile : IDENT",
	"lnkfile : STRINGLIT",
	"global : GLOBAL",
	"global : GLOBAL idlist",
	"record : RECORD IDENT",
	"record : RECORD IDENT LPAREN fldlist RPAREN",
	"fldlist : /* empty */",
	"fldlist : idlist",
	"proc : prochead SEMICOL locals initial procbody END",
	"prochead : PROCEDURE IDENT",
	"prochead : PROCEDURE IDENT LPAREN arglist RPAREN",
	"arglist : /* empty */",
	"arglist : idlist",
	"arglist : idlist LBRACK RBRACK",
	"idlist : IDENT",
	"idlist : idlist COMMA IDENT",
	"locals : /* empty */",
	"locals : locals retention idlist SEMICOL",
	"retention : LOCAL",
	"retention : STATIC",
	"initial : /* empty */",
	"initial : INITIAL expr SEMICOL",
	"procbody : /* empty */",
	"procbody : nexpr SEMICOL procbody",
	"nexpr : /* empty */",
	"nexpr : expr",
	"expr : expr1a",
	"expr : expr AND expr1a",
	"expr1a : expr1",
	"expr1a : expr1a QMARK expr1",
	"expr1 : expr2",
	"expr1 : expr2 SWAP expr1",
	"expr1 : expr2 ASSIGN expr1",
	"expr1 : expr2 REVSWAP expr1",
	"expr1 : expr2 REVASSIGN expr1",
	"expr1 : expr2 AUGCONCAT expr1",
	"expr1 : expr2 AUGLCONCAT expr1",
	"expr1 : expr2 AUGDIFF expr1",
	"expr1 : expr2 AUGUNION expr1",
	"expr1 : expr2 AUGPLUS expr1",
	"expr1 : expr2 AUGMINUS expr1",
	"expr1 : expr2 AUGSTAR expr1",
	"expr1 : expr2 AUGINTER expr1",
	"expr1 : expr2 AUGSLASH expr1",
	"expr1 : expr2 AUGMOD expr1",
	"expr1 : expr2 AUGCARET expr1",
	"expr1 : expr2 AUGNMEQ expr1",
	"expr1 : expr2 AUGEQUIV expr1",
	"expr1 : expr2 AUGNMGE expr1",
	"expr1 : expr2 AUGNMGT expr1",
	"expr1 : expr2 AUGNMLE expr1",
	"expr1 : expr2 AUGNMLT expr1",
	"expr1 : expr2 AUGNMNE expr1",
	"expr1 : expr2 AUGNEQUIV expr1",
	"expr1 : expr2 AUGSEQ expr1",
	"expr1 : expr2 AUGSGE expr1",
	"expr1 : expr2 AUGSGT expr1",
	"expr1 : expr2 AUGSLE expr1",
	"expr1 : expr2 AUGSLT expr1",
	"expr1 : expr2 AUGSNE expr1",
	"expr1 : expr2 AUGQMARK expr1",
	"expr1 : expr2 AUGAND expr1",
	"expr1 : expr2 AUGAT expr1",
	"expr2 : expr3",
	"expr2 : expr2 TO expr3",
	"expr2 : expr2 TO expr3 BY expr3",
	"expr3 : expr4",
	"expr3 : expr4 BAR expr3",
	"expr4 : expr5",
	"expr4 : expr4 SEQ expr5",
	"expr4 : expr4 SGE expr5",
	"expr4 : expr4 SGT expr5",
	"expr4 : expr4 SLE expr5",
	"expr4 : expr4 SLT expr5",
	"expr4 : expr4 SNE expr5",
	"expr4 : expr4 NMEQ expr5",
	"expr4 : expr4 NMGE expr5",
	"expr4 : expr4 NMGT expr5",
	"expr4 : expr4 NMLE expr5",
	"expr4 : expr4 NMLT expr5",
	"expr4 : expr4 NMNE expr5",
	"expr4 : expr4 EQUIV expr5",
	"expr4 : expr4 NEQUIV expr5",
	"expr5 : expr6",
	"expr5 : expr5 CONCAT expr6",
	"expr5 : expr5 LCONCAT expr6",
	"expr6 : expr7",
	"expr6 : expr6 PLUS expr7",
	"expr6 : expr6 DIFF expr7",
	"expr6 : expr6 UNION expr7",
	"expr6 : expr6 MINUS expr7",
	"expr7 : expr8",
	"expr7 : expr7 STAR expr8",
	"expr7 : expr7 INTER expr8",
	"expr7 : expr7 SLASH expr8",
	"expr7 : expr7 MOD expr8",
	"expr8 : expr9",
	"expr8 : expr9 CARET expr8",
	"expr9 : expr10",
	"expr9 : expr9 BACKSLASH expr10",
	"expr9 : expr9 AT expr10",
	"expr9 : expr9 BANG expr10",
	"expr10 : expr11",
	"expr10 : AT expr10",
	"expr10 : NOT expr10",
	"expr10 : BAR expr10",
	"expr10 : CONCAT expr10",
	"expr10 : LCONCAT expr10",
	"expr10 : DOT expr10",
	"expr10 : BANG expr10",
	"expr10 : DIFF expr10",
	"expr10 : PLUS expr10",
	"expr10 : STAR expr10",
	"expr10 : SLASH expr10",
	"expr10 : CARET expr10",
	"expr10 : INTER expr10",
	"expr10 : TILDE expr10",
	"expr10 : MINUS expr10",
	"expr10 : NMEQ expr10",
	"expr10 : NMNE expr10",
	"expr10 : SEQ expr10",
	"expr10 : SNE expr10",
	"expr10 : EQUIV expr10",
	"expr10 : UNION expr10",
	"expr10 : QMARK expr10",
	"expr10 : NEQUIV expr10",
	"expr10 : BACKSLASH expr10",
	"expr11 : literal",
	"expr11 : section",
	"expr11 : return",
	"expr11 : if",
	"expr11 : case",
	"expr11 : while",
	"expr11 : until",
	"expr11 : every",
	"expr11 : repeat",
	"expr11 : CREATE expr",
	"expr11 : IDENT",
	"expr11 : NEXT",
	"expr11 : BREAK nexpr",
	"expr11 : LPAREN exprlist RPAREN",
	"expr11 : LBRACE compound RBRACE",
	"expr11 : LBRACK exprlist RBRACK",
	"expr11 : expr11 LBRACK exprlist RBRACK",
	"expr11 : expr11 LBRACE RBRACE",
	"expr11 : expr11 LBRACE pdcolist RBRACE",
	"expr11 : expr11 LPAREN exprlist RPAREN",
	"expr11 : expr11 DOT IDENT",
	"expr11 : AND FAIL",
	"expr11 : AND IDENT",
	"while : WHILE expr",
	"while : WHILE expr DO expr",
	"until : UNTIL expr",
	"until : UNTIL expr DO expr",
	"every : EVERY expr",
	"every : EVERY expr DO expr",
	"repeat : REPEAT expr",
	"return : FAIL",
	"return : RETURN nexpr",
	"return : SUSPEND nexpr",
	"return : SUSPEND expr DO expr",
	"if : IF expr THEN expr",
	"if : IF expr THEN expr ELSE expr",
	"case : CASE expr OF LBRACE caselist RBRACE",
	"caselist : cclause",
	"caselist : caselist SEMICOL cclause",
	"cclause : DEFAULT COLON expr",
	"cclause : expr COLON expr",
	"exprlist : nexpr",
	"exprlist : exprlist COMMA nexpr",
	"pdcolist : nexpr",
	"pdcolist : pdcolist COMMA nexpr",
	"literal : INTLIT",
	"literal : REALLIT",
	"literal : STRINGLIT",
	"literal : CSETLIT",
	"section : expr11 LBRACK expr sectop expr RBRACK",
	"sectop : COLON",
	"sectop : PCOLON",
	"sectop : MCOLON",
	"compound : nexpr",
	"compound : nexpr SEMICOL compound",
	"program : error decls EOFX",
	"proc : prochead error procbody END",
	"expr : error",
};
#endif
#line 1 "/usr/lib/yaccpar"
/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	{ free(yys); free(yyv); return(0); }
#define YYABORT		{ free(yys); free(yyv); return(1); }
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		tsyserr("parser: syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-1000)

/*
** static variables used by the parser
*/
static YYSTYPE *yyv;			/* value stack */
static int *yys;			/* state stack */

static YYSTYPE *yypv;			/* top of value stack */
static int *yyps;			/* top of state stack */

static int yystate;			/* current state */
static int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */

int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */


/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
int
yyparse()
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */
	unsigned yymaxdepth = YYMAXDEPTH;

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
	yys = (int*)malloc(yymaxdepth*sizeof(int));
	if (!yyv || !yys)
	{
		tsyserr("parser: out of memory" );
		return(1);
	}
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			(void)printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			int yyps_index = (yy_ps - yys);
			int yypv_index = (yy_pv - yyv);
			int yypvt_index = (yypvt - yyv);
			yymaxdepth += YYMAXDEPTH;
			yyv = (YYSTYPE*)realloc((char*)yyv,
				yymaxdepth * sizeof(YYSTYPE));
			yys = (int*)realloc((char*)yys,
				yymaxdepth * sizeof(int));
			if (!yyv || !yys)
			{
				tsyserr("parse stack overflow" );
				return(1);
			}
			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			(void)printf( "Received token " );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				(void)printf( "Received token " );
				if ( yychar == 0 )
					(void)printf( "end-of-file\n" );
				else if ( yychar < 0 )
					(void)printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					(void)printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror(yychar, yylval, yy_state );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
				yynerrs++;
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						(void)printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					(void)printf( "Error recovery discards " );
					if ( yychar == 0 )
						(void)printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						(void)printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						(void)printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			(void)printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{

case 1:
# line 179 "tgram.g"
{gout(globfile);} break;
case 4:
# line 184 "tgram.g"
{if (!nocode) rout(globfile, Str0(yypvt[-0])); nocode = 0; loc_init();} break;
case 5:
# line 185 "tgram.g"
{if (!nocode) codegen(yypvt[-0]); nocode = 0; loc_init();} break;
case 6:
# line 186 "tgram.g"
{;} break;
case 7:
# line 187 "tgram.g"
{;} break;
case 8:
# line 188 "tgram.g"
{;} break;
case 9:
# line 190 "tgram.g"
{;} break;
case 11:
# line 193 "tgram.g"
{;} break;
case 12:
# line 195 "tgram.g"
{addinvk(Str0(yypvt[-0]),1);} break;
case 13:
# line 196 "tgram.g"
{addinvk(Str0(yypvt[-0]),2);} break;
case 14:
# line 197 "tgram.g"
{addinvk(Str0(yypvt[-2]),3);} break;
case 15:
# line 199 "tgram.g"
{;} break;
case 17:
# line 202 "tgram.g"
{;} break;
case 18:
# line 204 "tgram.g"
{addlfile(Str0(yypvt[-0]));} break;
case 19:
# line 205 "tgram.g"
{addlfile(Str0(yypvt[-0]));} break;
case 20:
# line 207 "tgram.g"
{idflag = F_Global;} break;
case 21:
# line 207 "tgram.g"
{;} break;
case 22:
# line 209 "tgram.g"
{idflag = F_Argument;} break;
case 23:
# line 209 "tgram.g"
{
		install(Str0(yypvt[-4]),F_Record|F_Global,id_cnt); yyval = yypvt[-4];
		} break;
case 24:
# line 213 "tgram.g"
{id_cnt = 0;} break;
case 25:
# line 214 "tgram.g"
{;} break;
case 26:
# line 216 "tgram.g"
{
		yyval = tree6(N_Proc,yypvt[-5],yypvt[-5],yypvt[-2],yypvt[-1],yypvt[-0]);
		} break;
case 27:
# line 220 "tgram.g"
{idflag = F_Argument;} break;
case 28:
# line 220 "tgram.g"
{
		yyval = yypvt[-4]; install(Str0(yypvt[-4]),F_Proc|F_Global,id_cnt);
		} break;
case 29:
# line 224 "tgram.g"
{id_cnt = 0;} break;
case 30:
# line 225 "tgram.g"
{;} break;
case 31:
# line 226 "tgram.g"
{id_cnt = -id_cnt;} break;
case 32:
# line 229 "tgram.g"
{
		install(Str0(yypvt[-0]),idflag,0); id_cnt = 1;
		} break;
case 33:
# line 232 "tgram.g"
{
		install(Str0(yypvt[-0]),idflag,0); ++id_cnt;
		} break;
case 34:
# line 236 "tgram.g"
{;} break;
case 35:
# line 237 "tgram.g"
{;} break;
case 36:
# line 239 "tgram.g"
{idflag = F_Dynamic;} break;
case 37:
# line 240 "tgram.g"
{idflag = F_Static;} break;
case 38:
# line 242 "tgram.g"
{yyval = tree1(N_Empty);} break;
case 39:
# line 243 "tgram.g"
{yyval = yypvt[-1];} break;
case 40:
# line 245 "tgram.g"
{yyval = tree1(N_Empty);} break;
case 41:
# line 246 "tgram.g"
{yyval = tree4(N_Slist,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 42:
# line 248 "tgram.g"
{yyval = tree1(N_Empty);} break;
case 45:
# line 252 "tgram.g"
{yyval = tree5(N_Conj,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 47:
# line 255 "tgram.g"
{yyval = tree5(N_Scan,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 49:
# line 258 "tgram.g"
case 50:
# line 259 "tgram.g"
case 51:
# line 260 "tgram.g"
case 52:
# line 261 "tgram.g"
{yyval = tree5(N_Binop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 53:
# line 262 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 54:
# line 263 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 55:
# line 264 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 56:
# line 265 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 57:
# line 266 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 58:
# line 267 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 59:
# line 268 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 60:
# line 269 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 61:
# line 270 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 62:
# line 271 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 63:
# line 272 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 64:
# line 273 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 65:
# line 274 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 66:
# line 275 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 67:
# line 276 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 68:
# line 277 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 69:
# line 278 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 70:
# line 279 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 71:
# line 280 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 72:
# line 281 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 73:
# line 282 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 74:
# line 283 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 75:
# line 284 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 76:
# line 285 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 77:
# line 286 "tgram.g"
{yyval = tree5(N_Augop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 78:
# line 287 "tgram.g"
{yyval = tree5(N_Scan,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 79:
# line 288 "tgram.g"
{yyval = tree5(N_Conj,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 80:
# line 289 "tgram.g"
{yyval = tree5(N_Activat,yypvt[-1],yypvt[-1],yypvt[-0],yypvt[-2]);} break;
case 82:
# line 292 "tgram.g"
{yyval = tree4(N_To,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 83:
# line 293 "tgram.g"
{yyval = tree5(N_ToBy,yypvt[-3],yypvt[-4],yypvt[-2],yypvt[-0]);} break;
case 85:
# line 296 "tgram.g"
{yyval = tree4(N_Alt,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 87:
# line 299 "tgram.g"
case 88:
# line 300 "tgram.g"
case 89:
# line 301 "tgram.g"
case 90:
# line 302 "tgram.g"
case 91:
# line 303 "tgram.g"
case 92:
# line 304 "tgram.g"
case 93:
# line 305 "tgram.g"
case 94:
# line 306 "tgram.g"
case 95:
# line 307 "tgram.g"
case 96:
# line 308 "tgram.g"
case 97:
# line 309 "tgram.g"
case 98:
# line 310 "tgram.g"
case 99:
# line 311 "tgram.g"
case 100:
# line 312 "tgram.g"
case 102:
# line 315 "tgram.g"
case 103:
# line 316 "tgram.g"
case 105:
# line 319 "tgram.g"
case 106:
# line 320 "tgram.g"
case 107:
# line 321 "tgram.g"
case 108:
# line 322 "tgram.g"
case 110:
# line 325 "tgram.g"
case 111:
# line 326 "tgram.g"
case 112:
# line 327 "tgram.g"
case 113:
# line 328 "tgram.g"
case 115:
# line 331 "tgram.g"
{yyval = tree5(N_Binop,yypvt[-1],yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 117:
# line 334 "tgram.g"
{yyval = tree4(N_Limit,yypvt[-2],yypvt[-2],yypvt[-0]);} break;
case 118:
# line 335 "tgram.g"
{yyval = tree5(N_Activat,yypvt[-1],yypvt[-1],yypvt[-0],yypvt[-2]);} break;
case 119:
# line 336 "tgram.g"
{yyval = tree4(N_Apply,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 121:
# line 339 "tgram.g"
{yyval = tree5(N_Activat,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 122:
# line 340 "tgram.g"
{yyval = tree3(N_Not,yypvt[-0],yypvt[-0]);} break;
case 123:
# line 341 "tgram.g"
{yyval = tree3(N_Bar,yypvt[-0],yypvt[-0]);} break;
case 124:
# line 342 "tgram.g"
{yyval = tree3(N_Bar,yypvt[-0],yypvt[-0]);} break;
case 125:
# line 343 "tgram.g"
{yyval = tree3(N_Bar,yypvt[-0],yypvt[-0]);} break;
case 126:
# line 344 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 127:
# line 345 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 128:
# line 346 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 129:
# line 347 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 130:
# line 348 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 131:
# line 349 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 132:
# line 350 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 133:
# line 351 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 134:
# line 352 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 135:
# line 353 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 136:
# line 354 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 137:
# line 355 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 138:
# line 356 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 139:
# line 357 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 140:
# line 358 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 141:
# line 359 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 142:
# line 360 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 143:
# line 361 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 144:
# line 362 "tgram.g"
{yyval = tree4(N_Unop,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 154:
# line 373 "tgram.g"
{yyval = tree3(N_Create,yypvt[-1],yypvt[-0]);} break;
case 155:
# line 374 "tgram.g"
{Val0(yypvt[-0]) = putloc(Str0(yypvt[-0]),0);} break;
case 156:
# line 375 "tgram.g"
{yyval = tree2(N_Next,yypvt[-0]);} break;
case 157:
# line 376 "tgram.g"
{yyval = tree3(N_Break,yypvt[-1],yypvt[-0]);} break;
case 158:
# line 377 "tgram.g"
{if ((yypvt[-1])->n_type == N_Elist) yyval = tree4(N_Invok,yypvt[-2],tree1(N_Empty),yypvt[-1]); else yyval = yypvt[-1];} break;
case 159:
# line 378 "tgram.g"
{yyval = yypvt[-1];} break;
case 160:
# line 379 "tgram.g"
{yyval = tree3(N_List,yypvt[-2],yypvt[-1]);} break;
case 161:
# line 380 "tgram.g"
{yyval = buildarray(yypvt[-3],yypvt[-2],yypvt[-1],yypvt[-0]);} break;
case 162:
# line 381 "tgram.g"
{yyval = tree4(N_Invok,yypvt[-1],yypvt[-2], tree3(N_List,yypvt[-1],tree1(N_Empty)));} break;
case 163:
# line 382 "tgram.g"
{yyval = tree4(N_Invok,yypvt[-2],yypvt[-3],tree3(N_List,yypvt[-2],yypvt[-1]));} break;
case 164:
# line 383 "tgram.g"
{yyval = tree4(N_Invok,yypvt[-2],yypvt[-3],yypvt[-1]);} break;
case 165:
# line 384 "tgram.g"
{yyval = tree4(N_Field,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 166:
# line 385 "tgram.g"
{yyval = c_str_leaf(N_Key,yypvt[-1],"fail");} break;
case 167:
# line 386 "tgram.g"
{if (klookup(Str0(yypvt[-0])) == 0) tfatal("invalid keyword",Str0(yypvt[-0])); yyval = c_str_leaf(N_Key,yypvt[-1],Str0(yypvt[-0]));} break;
case 168:
# line 388 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 169:
# line 389 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-3],yypvt[-3],yypvt[-2],yypvt[-0]);} break;
case 170:
# line 391 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 171:
# line 392 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-3],yypvt[-3],yypvt[-2],yypvt[-0]);} break;
case 172:
# line 394 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 173:
# line 395 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-3],yypvt[-3],yypvt[-2],yypvt[-0]);} break;
case 174:
# line 397 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 175:
# line 399 "tgram.g"
{yyval = tree4(N_Ret,yypvt[-0],yypvt[-0],tree1(N_Empty));} break;
case 176:
# line 400 "tgram.g"
{yyval = tree4(N_Ret,yypvt[-1],yypvt[-1],yypvt[-0]);} break;
case 177:
# line 401 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-1],yypvt[-1],yypvt[-0],tree1(N_Empty));} break;
case 178:
# line 402 "tgram.g"
{yyval = tree5(N_Loop,yypvt[-3],yypvt[-3],yypvt[-2],yypvt[-0]);} break;
case 179:
# line 404 "tgram.g"
{yyval = tree5(N_If,yypvt[-3],yypvt[-2],yypvt[-0],tree1(N_Empty));} break;
case 180:
# line 405 "tgram.g"
{yyval = tree5(N_If,yypvt[-5],yypvt[-4],yypvt[-2],yypvt[-0]);} break;
case 181:
# line 407 "tgram.g"
{yyval = tree4(N_Case,yypvt[-5],yypvt[-4],yypvt[-1]);} break;
case 183:
# line 410 "tgram.g"
{yyval = tree4(N_Clist,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 184:
# line 412 "tgram.g"
{yyval = tree4(N_Ccls,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 185:
# line 413 "tgram.g"
{yyval = tree4(N_Ccls,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 186:
# line 415 "tgram.g"
{;} break;
case 187:
# line 416 "tgram.g"
{yyval = tree4(N_Elist,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
case 188:
# line 418 "tgram.g"
{
		yyval = tree3(N_Create,yypvt[-0],yypvt[-0]);
		} break;
case 189:
# line 421 "tgram.g"
{
		yyval = tree4(N_Elist,yypvt[-1],yypvt[-2],tree3(N_Create,yypvt[-1],yypvt[-0]));
		} break;
case 190:
# line 425 "tgram.g"
{Val0(yypvt[-0]) = putlit(Str0(yypvt[-0]),F_IntLit,0);} break;
case 191:
# line 426 "tgram.g"
{Val0(yypvt[-0]) = putlit(Str0(yypvt[-0]),F_RealLit,0);} break;
case 192:
# line 427 "tgram.g"
{Val0(yypvt[-0]) = putlit(Str0(yypvt[-0]),F_StrLit,(int)Val1(yypvt[-0]));} break;
case 193:
# line 428 "tgram.g"
{Val0(yypvt[-0]) = putlit(Str0(yypvt[-0]),F_CsetLit,(int)Val1(yypvt[-0]));} break;
case 194:
# line 430 "tgram.g"
{yyval = tree6(N_Sect,yypvt[-2],yypvt[-2],yypvt[-5],yypvt[-3],yypvt[-1]);} break;
case 195:
# line 432 "tgram.g"
{yyval = yypvt[-0];} break;
case 196:
# line 433 "tgram.g"
{yyval = yypvt[-0];} break;
case 197:
# line 434 "tgram.g"
{yyval = yypvt[-0];} break;
case 199:
# line 437 "tgram.g"
{yyval = tree4(N_Slist,yypvt[-1],yypvt[-2],yypvt[-0]);} break;
	}
	goto yystack;		/* reset registers in driver code */
}
