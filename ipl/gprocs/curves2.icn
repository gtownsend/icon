############################################################################
#
#	File:     curves2.icn
#
#	Subject:  Procedures to generate points on plain curves
#
#	Author:   Ralph E. Griswold
#
#	Date:     October 5, 1993
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  See curves.icn, which includes this file, for general documentation.
#
############################################################################

procedure bullet_nose(x, y, a, b, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * cos(theta),
         y + b * tan(&pi / 2 - theta)
         )

end

procedure cissoid_diocles(x, y, a, steps, lo, hi)
   local incr, theta, radius

   /steps := 300
   lo := dtor(\lo) | (-2 * &pi)
   hi := dtor(\hi) | (2 * &pi)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      radius := a * sin(theta) * cos(theta)
      suspend Point(
         x + radius * cos(theta),
         y + radius * sin(theta)
         )
      }

end

procedure cross_curve(x, y, a, b, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a / cos(theta),
         y + b / sin(theta)
         )

end

procedure cycloid(x, y, a, b, steps, lo, hi)
   local incr, theta

   /steps := 100
   lo := dtor(\lo) | 0
   hi := dtor(\hi) | (8 * &pi)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * theta - b * sin(theta),
         y + a - b * cos(theta)
         )

end

procedure kampyle_exodus(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | (-&pi / 2)
   hi := dtor(\hi) | (3 * &pi / 2)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := a / cos(theta)
      suspend Point(
         x + fact,
         y + fact * tan(theta)
         )
      }

end

procedure kappa(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | 0
   hi := dtor(\hi) | (2 * &pi)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := a * cos(theta)
      suspend Point(
         x + fact / (0 ~= tan(theta)),
         y + fact
         )
      }

end

procedure line(x, y, x1, y1, steps)
   local xincr, yincr

   /steps := 100

   xincr := (x1 - x)  / (steps - 1)
   yincr := (y1 - y) / (steps - 1)

   every 1 to steps do {
      suspend Point(x, y)
      x +:= xincr
      y +:= yincr
      }

end

#  Needs to be checked out

procedure parabola(x, y, a, steps, lo, hi)
   local incr, theta, denom, radius

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      denom := 1 - cos(theta)
      if denom = 0 then next
      radius := 2 * a / denom
      suspend Point(
         radius * cos(theta),
         radius * sin(theta)
         )
      }

end

procedure trisectrix_catalan(x, y, a, steps, lo, hi)
   local incr, theta, radius

   /steps := 300
   lo := dtor(\lo) | (-2 * &pi)
   hi := dtor(\hi) | (2 * &pi)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      radius := a / cos(theta / 3) ^ 3
      suspend Point(
         x + radius * cos(theta),
         y + radius * sin(theta)
         )
      }

end

procedure trisectrix_maclaurin(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | (-&pi / 2)
   hi := dtor(\hi) | (&pi / 2)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := a * (1 - 4 * cos(theta) ^ 2)
      suspend Point(
         x + fact,
         y + fact * tan(theta)
         )
      }

end

procedure witch_agnesi(x, y, a, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | (-&pi /2)
   hi := dtor(\hi) | (&pi / 2)
   incr := (hi - lo) / steps

   fact := 2 * a

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + fact * tan(theta),
         y - fact * cos(theta) ^ 2
         )

end
