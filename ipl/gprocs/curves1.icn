############################################################################
#
#	File:     curves1.icn
#
#	Subject:  Procedures to generate points on plain curves
#
#	Author:   Ralph E. Griswold
#
#	Date:     October 5, 1993
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  See curves.icn, which includes this file, for general documentation.
#
############################################################################

procedure cardioid(x, y, a, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := 2 * a * (1 + cos(theta))
      suspend Point(
         x + cos(theta) * fact,
         y + sin(theta) * fact
         )
      }

end

procedure deltoid(x, y, a, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * (2 * cos(theta) + cos(2 * theta)),
         y + a * (2 * sin(theta) - sin(2 * theta))
         )

end

procedure ellipse(x, y, a, b, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * cos(theta),
         y + b * sin(theta)
         )

end

procedure ellipse_evolute(x, y, a, b, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * cos(theta) ^ 3,
         y + b * sin(theta) ^ 3
         )

end

procedure epitrochoid(x, y, a, b, h, steps, lo, hi)
   local incr, theta, sum, fact

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   sum := a + b
   fact := sum / b

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + sum * cos(theta) - h * cos(fact * theta),
         y + sum * sin(theta) - h * sin(fact * theta)
         )

end

procedure folium(x, y, a, b, steps, lo, hi)
   local incr, theta, radius

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      radius := (3 * a * sin(theta) * cos(theta)) /
         (sin(theta) ^ 2 + cos(theta) ^ 2)
      suspend Point(
         x + radius * cos(theta),
         y + radius * sin(theta)
         )
      }

end

procedure hippopede(x, y, a, b, steps, lo, hi)
   local incr, theta, mul

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      mul := a * b - b ^ 2 * sin(theta) ^ 2
      if mul < 0 then next
      mul := 2 * sqrt(mul)
      suspend Point(
         x + mul *  cos(theta),
         y + mul *sin(theta)
         )
      }

end

procedure lemniscate_bernoulli(x, y, a, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := a * cos(theta) / (1 + sin(theta) ^ 2)
      suspend Point(
         x + fact,
         y + fact * sin(theta)
         )
      }

end

procedure lemniscate_gerono(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact :=  a * cos(theta)
      suspend Point(
         x + fact,
         y + sin(theta) * fact
         )
      }

end

procedure limacon_pascal(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := b + 2 * a * cos(theta)
      suspend Point(
         x + fact * cos(theta),
         y + fact * sin(theta)
         )
      }

end

procedure lissajous(x, y, a, b, r, delta, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | 0
   hi := dtor(\hi) | (16 * &pi)
   incr := (hi - lo) / steps

   r := dtor(r)

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * sin(r * theta + delta),
         y + b * sin(theta)
         )

end

procedure nephroid(x, y, a, steps, lo, hi)
   local incr, theta

   /steps := 300
   lo := dtor(\lo) | -&pi
   hi := dtor(\hi) | &pi
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do
      suspend Point(
         x + a * (3 * cos(theta) - cos(3 * theta)),
         y + a * (3 * sin(theta) - sin(3 * theta))
         )

end

procedure piriform(x, y, a, b, steps, lo, hi)
   local incr, theta, fact

   /steps := 300
   lo := dtor(\lo) | (-&pi / 2)
   hi := dtor(\hi) | (3 * &pi / 2)
   incr := (hi - lo) / steps

   every theta := step(lo, hi, incr) do {
      fact := 1 + sin(theta)
      suspend Point(
         x + a * fact,
         y + b * cos(theta) * fact
         )
      }

end
